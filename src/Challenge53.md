# Solution to Challenge 53

```haskell
module Challenge53
  (
    collideLong
  ) where

import Bytes ( Bytes, chunksOf )
import Hash.Collision ( findCollision2 )

import Control.Monad ( replicateM )
import Data.List ( foldl', scanl', mapAccumL )
import Data.Maybe ( maybeToList )
import Data.Tuple ( swap )

import Math.NumberTheory.Logarithms ( integerLog2 )

import qualified Data.Map as M
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC
```

For this Challenge, we want to create a collision of one block
against 2^k+1 blocks.
then using the final state as the starting point
for the search against a block hashed from the starting IV directly.

```haskell
collideK :: (Bytes -> Bytes -> Bytes) -> Int -> Bytes -> ((Bytes,Bytes), Bytes)
collideK hashOne k iv =
  let blockSize = 16
```

Rather than hash 2^k+1 blocks every time,
we create a single "dummy" sequence of 2^k blocks,

```haskell
      dummy = BC.replicate (2^k * blockSize) 'X'
```

hash it against the starting state,

```haskell
      dummyHash = foldl' hashOne iv $ chunksOf blockSize dummy
```

and use this hash as a starting point for the collision search.

```haskell
      Just ((b1,b2),h) = findCollision2 (hashOne iv) allBlocks
                                        (hashOne dummyHash) allBlocks
```

We then return the collision we found:
the single block, and the dummy with a single block appended.

```haskell
  in  ((b1, dummy <> b2), h)
```

Again, our list of all possible blocks is generated by `replicateM`
in the list monad from an input alphabet of the lower-case letters.

```haskell
allBlocks :: [Bytes]
allBlocks = map BC.pack $ replicateM 16 ['a'..'z']
```

We iterate `collideK` to get a list of collisions of increasing size,
starting from the input IV.
This is like the multi-block collision of the last Challenge,
but the kth collision is between a single block
and a sequence of 2^k+1 blocks.

```haskell
collideAllK :: (Bytes -> Bytes -> Bytes) -> Bytes -> [(Bytes,Bytes)]
collideAllK hashOne iv = snd $ mapAccumL nextCollision iv [0..]
 where
```

`nextCollision` generates collision k, given the input hash state h:

```haskell
  nextCollision h k = swap $ collideK hashOne k h
```

Our goal in this Challenge is to generate a hash collision
for a long message that is of exactly the same length.
Using `collideAllK`, we can create an "expandable message",
a bunch of messages which hash to the same thing
and are of any length between `k` and `k + 2^k - 1`.
We can then try to collide into the blocks of the message,
using the length variant that exactly matches the blocks we're replacing.

```haskell
collideLong :: (Bytes -> Bytes -> Bytes) -> Bytes -> Bytes -> Bytes
collideLong hashOne iv message =
  let blockSize = 16
      msgBlocks = chunksOf blockSize message
      numBlocks = length msgBlocks
```

We want to find an expandable message of length up to `numBlocks`.
We thus need `ceiling(log(number of blocks))`, or

```haskell
      numExpandable = integerLog2 (fromIntegral numBlocks) + 1
      expandable = take numExpandable (collideAllK hashOne iv)
```

The final hash of the expandable message
is most easily computed by just hashing the single-block forms of each segment.

```haskell
      expandableHash = foldl' hashOne iv (map fst expandable)
```

We compute all of the intermediate hashes in the long message,
recording which block each of them comes before.
Our expandable message is at least `numExpandable` blocks long,
so we don't bother recording the hashes before that point.

```haskell
      interHashes = tail $ scanl' hashOne iv msgBlocks
      interHashMap = M.fromList $ drop (numExpandable - 1) $
                     zip interHashes [1..]
```

We want to find a glue block which,
when hashed with IV equal to the expandable message hash,
gives one of the intermediate hashes of the long message.
We just try all of the alphabetic blocks until we get one that works.

```haskell
      (glueBlock, gluePos) =
        head [ (block, pos)
             | block <- allBlocks
             , let hash = hashOne expandableHash block
             , pos <- maybeToList (interHashMap M.!? hash) ]
```

Now we can form the final forged message.
We need to insert exactly the correct lengths of the expandable message
to make the final forgery the correct length.
We'll need to choose the blocks of the expandable message
that match the individual bits of the glue position.
If each bit is a zero, we choose the one-block form;
if a one, the 2^k-block form.

```haskell
      bitPick n (b1,b2k) = case n `quotRem` 2 of
        (n2,0) -> (n2,b1)
        (n2,1) -> (n2,b2k)
```

We can just `mapAccumL` this over the expandable blocks
to pick all of the ones we need.

```haskell
      expanded = snd $ mapAccumL bitPick (gluePos - numExpandable - 1)
                                 expandable
```

Finally, we construct our forged message
by concatenating the expanded blocks, the glue block,
and the rest of the original message.

```haskell
  in  B.concat $ expanded ++ [ glueBlock
                             , B.drop (gluePos * blockSize) message ]
```
