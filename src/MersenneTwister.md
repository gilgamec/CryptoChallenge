# Mersenne Twister

This module implements the Mersenne Twister MT19937 PRNG, based on
[the pseudocode on Wikipedia](https://en.wikipedia.org/wiki/Mersenne_Twister#Pseudocode).

```haskell
module MersenneTwister
  (
    MTState(..)
  , mtSeed, mtExtract, mtExtractMany
  ) where

import Control.Monad ( forM_ )
import Data.Bits ( Bits(..) )
import Data.Bifunctor ( first )
import Data.List ( foldl', scanl', tails )
import Data.Word ( Word32 )

import qualified Data.Vector.Unboxed as V
import qualified Data.Vector.Unboxed.Mutable as MV
```

The Mersenne Twister has a *state*,
which is simply a block of 32-bit values,
each of which will be *tempered* to create an output value.
Once these values are exhausted, it *twists* the state
to generate the next block of values.
It thus has to also keep track of how many values
it has generated so far for this block.

```haskell
data MTState = MT
  { mtCycle :: {-# UNPACK #-} !Int
  , mtState :: !(V.Vector Word32) }
  deriving (Eq,Ord,Show)
```

The state vector will consist of 624 32-bit words.
These, along with other magic numbers,
are required by the algorithm.

```haskell
mtN = 624
mtW = 32
```

A new state is created by *seeding* the random number generator,
given an initial seed value.

```haskell
mtSeed :: Word32 -> MTState
mtSeed seed =
```

The seed becomes the first element of the state vector,
and the rest is generated by the recurrence

    x_i = f * (x_i-1 XOR (x_i-1 >> (w-2))) + i.

```haskell
  let fmult x i = mtF * (x `xor` (x `shiftR` (mtW - 2))) + i
      state = V.scanl fmult seed $ V.fromListN (mtN - 1) [1..]
```

The initial cycle number is set to `N`, the length of the state vector,
signalling that the state will have to be twisted before a number is produced.

```haskell
  in  MT{ mtCycle = mtN, mtState = state }
```

`f`, the seed generation parameter, is another magic number.

```haskell
mtF = 1812433253
```

`mtExtract` gets the next value.
It returns both the value generated and the new `MTState`.

```haskell
mtExtract :: MTState -> (Word32,MTState)
```

If the cycle is `N`, then we've exhausted the state vector
and have to twist it before extracting a value.

```haskell
mtExtract mt
  | mtCycle mt == mtN = mtExtract (mtTwist mt)
```

Otherwise, we get the next value and temper it,
while advancing the counter.

```haskell
  | otherwise = ( mtTemper $ mtState mt V.! mtCycle mt
                , mt{ mtCycle = succ (mtCycle mt) } )
```

We can extract a list of many generated values using `mtExtractMany`.

```haskell
mtExtractMany :: Int -> MTState -> ([Word32],MTState)
mtExtractMany 0 st = ([],st)
mtExtractMany n st =
  let (x,st') = mtExtract st
  in  first (x:) $ mtExtractMany (n-1) st'
```

The tempering procedure consists of four shift-and-xor operations
using magic numbers.

```haskell
mtTemper :: Word32 -> Word32
mtTemper y0 =
  let y1 = y0 `xor` ((y0 `shiftR` mtU) .&. mtD)
      y2 = y1 `xor` ((y1 `shiftL` mtS) .&. mtB)
      y3 = y2 `xor` ((y2 `shiftL` mtT) .&. mtC)
  in  y3 `xor`  (y3 `shiftR` mtL)

mtU = 11
mtD = 0xFFFFFFFF

mtS = 7
mtB = 0x9D2C5680

mtT = 15
mtC = 0xEFC60000

mtL = 18
```

Finally, the twisting procedure completely rewrites the state vector.
The cycle number is reset to zero.

```haskell
mtTwist :: MTState -> MTState
mtTwist MT{ mtState = state } = MT 0 (twist state)
 where
```

The twist operation uses both old and new values of the state vector,
so we implement it with a mutable vector operation.
We perform a loop over each element in the vector,
from beginning to end.

```haskell
  twist :: V.Vector Word32 -> V.Vector Word32
  twist = V.modify $ \vec -> forM_ [0..mtN - 1] $ \i -> do
    let next1 = (i+1) `mod` mtN
        nextM = (i+mtM) `mod` mtN
    mti  <- MV.read vec i
    mti1 <- MV.read vec next1
    let x   = (mti .&. upperMask) + (mti1 .&. lowerMask)
        xA' = x `shiftR` 1
        xA  = if testBit x 0 then xA' `xor` mtA else xA'
    mtim <- MV.read vec nextM
    MV.write vec i $ mtim `xor` xA
```

Here we have more magic numbers.

```haskell
mtR = 31
mtM = 397
mtA = 0x9908B0DF

lowerMask, upperMask :: Word32
lowerMask = (1 `shiftL` mtR) - 1
upperMask = complement lowerMask
```
